# util.py
# in chat.common

from enum import Enum, EnumMeta
from typing import Optional


class interface(object):
    """An abstract `interface` that will be used in e.g. `model_from_proto`
       to autogenerate the sort of useful code we would like.

        attributes:
          `_fields_enum`: An `Enum` subclass which has members of the names
                          of the field name and values of the field type.
    """
    _fields_enum: Optional[type] = None


def model_from_proto(iface: interface) -> type:
    """Materializes a class with getters and setters from an interface.

        Raises: A `ValueError` if `iface` is not `interface` subclass,
                               if `iface._fields_enum` is not `Enum` subclass
                               if `iface._fields_enum`'s members do not have
                                 `str` names and `type` values.

        Returns: A `class` generated by the `iface : interface`.
    """
    if not issubclass(iface, interface):
        raise ValueError(f'Arg `iface` ({iface!r}) is not a subclass of '
                         f'`interface` (type is {type(iface)!r}).')

    if not hasattr(iface, '_fields_enum'):
        raise ValueError(f'Arg `iface` ({iface!r}) does not have a '
                         f'`_fields_enum` attribute.')

    not_enum = False
    if (type(iface._fields_enum) is not Enum and
            type(iface._fields_enum) is not EnumMeta):
        not_enum = True

    if not not_enum:
        if (not issubclass(iface._fields_enum, Enum) and
                not issubclass(iface._fields_enum, EnumMeta)):
            not_enum = True

    if not_enum:
        raise ValueError(f'Arg `iface`\'s `_fields_enum` attribute '
                         f'({iface._fields_enum!r}) is not an `Enum` '
                         f'(type is {type(iface._fields_enum)!r}).')

    return model_from_fields(**dict([(member.name, member.value)
                                     for _, member in
                                     iface._fields_enum.__members__.items()]))


def model_from_fields(**kwargs):

    class __impl_class__(object):
        pass

    # we may iterate an `Enum`'s members by this attribute (which is basically
    # a `dict`).
    for name, value in kwargs.items():
        if type(value) is not type:
            raise ValueError(f'Field \'{name!r}\' with value '
                             f'\'{value!r}\' which is not a `type`.')

        # note: you do NOT want to put `private_name` within any of the
        #       implementations that will be `setattr`ed, since then
        #       `private_name` the variable will be bound to the function.
        #       Another way would be to explicitly `del` it, but uh, that's
        #       not very pythonic...
        #
        #       For some stupid, hacky reason the default works.
        #       I guess since it puts it in the function's `__defaults__`
        #       attribute...
        private_name = f'_{name!s}'

        # the getter we'll add to `__impl_class__`.
        def __impl_setter__(self: __impl_class__,
                            val: Optional[value],
                            private_name: str = private_name):
            setattr(self, private_name, val)
            return self

        setattr(__impl_class__, f'set_{name!s}', __impl_setter__)

        # the setter we'll add to `__impl_class__`.
        def __impl_getter__(self: __impl_class__,
                            private_name: str = private_name):
            return getattr(self, private_name, None)

        setattr(__impl_class__, f'get_{name!s}', __impl_getter__)

        # default value, see the note on `__init__` for explanation.
        setattr(__impl_class__, private_name, None)

    # the `__init__` we'll add to `__impl_class__`.
    # Note that just doing the `Enum` members in the init itself (i.e. allocate
    # on instantiation) would carry around `iface`. That's annoying, so we'll
    # use the class attributes to set defaults (i.e. `None`).
    # There is a way to do this generation without carrying around `iface`
    # and having allocation on instantiation, using the `types` module, but
    # that's a bit of overkill at the end of the day, so not worth it.
    def __impl_init__(self) -> __impl_class__:
        pass

    setattr(__impl_class__, '__init__', __impl_init__)

    return __impl_class__
