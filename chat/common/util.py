# util.py
# in chat.common

from enum import Enum, EnumMeta
from typing import Optional


class interface(object):
    """An abstract `interface` that will be used in e.g. `class_from_proto`
       to autogenerate the sort of useful code we would like.

        attributes:
          `_fields_enum`: An `Enum` subclass which has members of the names
                          of the field name and values of the field type.
    """
    _fields_enum : Optional[type] = None


def class_from_proto(iface : interface) -> type:
    """Materializes a class with getters and setters from an interface.

        Raises: A `ValueError` if `iface` is not `interface` subclass,
                               if `iface._fields_enum` is not `Enum` subclass
                               if `iface._fields_enum`'s members do not have
                                 `str` names and `type` values.

        Returns: A `class` generated by the `iface : interface`.
    """
    if not issubclass(iface, interface):
        raise ValueError(f'Arg `iface` ({iface!r}) is not a subclass of '
                         f'`interface` (type is {type(iface)!r}).')

    if not hasattr(iface, '_fields_enum'):
        raise ValueError(f'Arg `iface` ({iface!r}) does not have a '
                         f'`_fields_enum` attribute.')

    not_enum = False
    if (type(iface._fields_enum) is not Enum and
        type(iface._fields_enum) is not EnumMeta):
        not_enum = True

    if not not_enum:
        if (not issubclass(iface._fields_enum, Enum) and
            not issubclass(iface._fields_enum, EnumMeta)):
            not_enum = True

    if not_enum:
        raise ValueError(f'Arg `iface`\'s `_fields_enum` attribute '
                         f'({iface._fields_enum!r}) is not an `Enum` '
                         f'(type is {type(iface._fields_enum)!r}).')

    class __impl_class__(object):
        pass

    # we may iterate an `Enum`'s members by this attribute (which is basically
    # a `dict`).
    for name, value in [(member.name, member.value)
                        for _, member in
                        iface._fields_enum.__members__.items()]:
        if type(value) is not type:
            raise ValueError(f'Arg `iface`\'s `_fields_enum` attribute '
                             f'has member \'{name!r}\' with value '
                             f'\'{value!r}\' which is not a `type`.')

        # note: you do NOT want to put `f'_{name!s}'` as a variable, because
        # it will bind, and everything will go to one place.

        # the getter we'll add to `__impl_class__`.
        # TODO: does this carry around `priv_name`? or is it constant?
        # probs a nit pick either way for this application.
        def __impl_setter__(self : __impl_class__, val : Optional[value]):
            setattr(self, f'_{name!s}', val)

        setattr(__impl_class__, f'set_{name!s}', __impl_setter__)

        # the setter we'll add to `__impl_class__`.
        def __impl_getter__(self : __impl_class__) -> Optional[value]:
            return getattr(self, f'_{name!s}', None)

        setattr(__impl_class__, f'get_{name!s}', __impl_getter__)

        # default value, see the note on `__init__` for explanation.
        setattr(__impl_class__, f'_{name!s}', None)

    # the `__init__` we'll add to `__impl_class__`.
    # Note that just doing the `Enum` members in the init itself (i.e. allocate
    # on instantiation) would carry around `iface`. That's annoying, so we'll
    # use the class attributes to set defaults (i.e. `None`).
    # There is a way to do this generation without carrying around `iface`
    # and having allocation on instantiation, using the `types` module, but
    # that's a bit of overkill at the end of the day, so not worth it.
    def __impl_init__(self) -> __impl_class__:
        pass

    setattr(__impl_class__, '__init__', __impl_init__)

    return __impl_class__
